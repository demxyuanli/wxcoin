# 预览窗口轮廓渲染的限制

## 问题分析

### Three.js OutlinePass 的实现
Three.js 使用完整的后处理管线：
1. 渲染场景到纹理
2. 在图像空间进行边缘检测（Sobel算子）
3. 只在深度/法线不连续的地方绘制轮廓
4. 轮廓完全贴合几何体，因为是基于渲染后的图像

### 我们预览窗口的限制
1. **没有完整的渲染管线**：预览窗口是独立的OpenGL上下文
2. **没有后处理支持**：无法进行图像空间的边缘检测
3. **只能使用传统OpenGL**：受限于Coin3D的渲染方式

### 当前尝试的方法及问题

#### 方法1：几何缩放
- **问题**：轮廓偏离几何体，不贴合
- **原因**：均匀缩放无法适应复杂形状

#### 方法2：线框渲染
- **问题**：显示所有边，包括内部边
- **原因**：无法区分轮廓边和内部边

#### 方法3：模板缓冲 + 缩放
- **问题**：仍然有偏移
- **原因**：本质还是几何缩放

## 真正的解决方案

### 选项1：实现简化的后处理
```cpp
// 需要的步骤：
1. 创建帧缓冲对象(FBO)
2. 渲染场景到纹理
3. 使用着色器进行边缘检测
4. 合成最终图像
```

### 选项2：使用真正的轮廓边检测
```cpp
// 计算轮廓边：
for each edge in mesh:
    if (face1.normal · view > 0 && face2.normal · view < 0):
        edge is silhouette
```

### 选项3：接受限制，使用折中方案
- 显示所有可见边，但通过背面剔除减少内部边
- 不完美，但可以给用户一个大概的效果预览

## 建议

对于预览窗口，建议：
1. **明确说明限制**：预览效果仅供参考
2. **专注于参数调试**：让用户了解参数的影响
3. **真正的效果**：在主窗口查看

对于主程序：
- 已经实现了proper的后处理轮廓
- 使用深度和法线边缘检测
- 效果应该接近Three.js

## 结论

预览窗口的轮廓效果确实无法完全贴合几何体，这是技术限制导致的。要实现Three.js那样的效果，需要：
1. 完整的后处理管线
2. 可编程着色器支持
3. 帧缓冲对象支持

这些在简单的预览窗口中实现过于复杂。建议将预览窗口定位为"参数调试工具"而非"精确预览"。