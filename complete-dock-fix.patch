diff --git a/dock-panel-dragging-complete-fix.patch b/dock-panel-dragging-complete-fix.patch
new file mode 100644
index 0000000..f438e7c
--- /dev/null
+++ b/dock-panel-dragging-complete-fix.patch
@@ -0,0 +1,301 @@
+diff --git a/docs/DockPanelDraggingFix.md b/docs/DockPanelDraggingFix.md
+deleted file mode 100644
+index 3008938..0000000
+--- a/docs/DockPanelDraggingFix.md
++++ /dev/null
+@@ -1,67 +0,0 @@
+-# Dock Panel Dragging Fix
+-
+-## Problem
+-When dragging dock panels to the direction indicators (dock guides), the dock layout was not changing and panels were not being properly docked.
+-
+-## Root Causes Identified
+-
+-1. **ApplyLayoutToWidgets not applying panel positions**: The `ApplyLayoutToWidgets` method in `LayoutEngine.cpp` was only handling splitter nodes but not applying the calculated layout positions to panel nodes.
+-
+-2. **FindTargetPanel always returning null**: The `FindTargetPanel` method in `DragDropController.cpp` had placeholder code that always returned `nullptr`, preventing proper target panel identification.
+-
+-3. **GetDockPosition not checking dock guides**: The `GetDockPosition` method in `ModernDockManager.cpp` was only checking mouse position relative to panels, not checking if the mouse was over dock guides.
+-
+-4. **No way to get target panel from dock guides**: When dragging over dock guides, there was no way to retrieve which panel the guides were associated with.
+-
+-## Solutions Applied
+-
+-### 1. Fixed ApplyLayoutToWidgets
+-Added code to apply layout to panel nodes:
+-```cpp
+-// If this is a panel node, apply its layout
+-if (node->GetType() == LayoutNodeType::Panel && node->GetPanel()) {
+-    wxRect rect = node->GetRect();
+-    node->GetPanel()->SetSize(rect);
+-    node->GetPanel()->Show();
+-}
+-```
+-
+-### 2. Implemented FindTargetPanel
+-Replaced placeholder with proper implementation that:
+-- Checks if the hit-tested window is already a ModernDockPanel
+-- Searches through all panels to find which one contains the hit-tested window
+-- Walks up the parent hierarchy to find the containing panel
+-
+-### 3. Updated GetDockPosition
+-Modified to check dock guides first:
+-```cpp
+-// First check if mouse is over a dock guide - this takes priority
+-if (m_dockGuides && m_dockGuides->IsVisible()) {
+-    DockPosition guidePosition = m_dockGuides->GetActivePosition();
+-    if (guidePosition != DockPosition::None) {
+-        return guidePosition;
+-    }
+-}
+-```
+-
+-### 4. Added GetDockGuideTarget Support
+-- Added `GetCurrentTarget()` method to DockGuides class
+-- Added `GetDockGuideTarget()` to IDockManager interface
+-- Implemented in ModernDockManager to return the current target panel from dock guides
+-- Updated ValidateDrop to use the target panel from dock guides when dragging over them
+-
+-### 5. Added GetAllPanels Method
+-- Added `GetAllPanels()` to IDockManager interface
+-- Implemented in ModernDockManager to return all panels
+-- Used in FindTargetPanel for searching through panels
+-
+-## Result
+-With these fixes, dragging dock panels to the direction indicators now properly:
+-1. Detects when the mouse is over a dock guide
+-2. Identifies the correct target panel
+-3. Calculates the appropriate dock position
+-4. Updates the layout tree structure
+-5. Applies the new layout to reposition panels
+-6. Shows the changes visually
+-
+-The dock panel system now correctly responds to dragging panels onto the directional guides, allowing users to dock panels to the left, right, top, bottom, or center (as tabs) of other panels.
+\ No newline at end of file
+diff --git a/src/widgets/LayoutEngine.cpp b/src/widgets/LayoutEngine.cpp
+index 1768b2c..ae31453 100644
+--- a/src/widgets/LayoutEngine.cpp
++++ b/src/widgets/LayoutEngine.cpp
+@@ -4,6 +4,7 @@
+ #include "DPIManager.h"
+ #include <wx/splitter.h>
+ #include <wx/sizer.h>
++#include <wx/log.h>
+ #include <algorithm>
+ 
+ // LayoutNode implementation
+@@ -181,7 +182,7 @@ void LayoutEngine::RemovePanel(ModernDockPanel* panel)
+     // Remove from tree
+     RemovePanelFromTree(panelNode);
+     
+-    // Clean up empty nodes
++    // Clean up empty nodes - but be careful not to remove nodes we might need
+     CleanupEmptyNodes();
+     
+     m_layoutDirty = true;
+@@ -202,9 +203,15 @@ bool LayoutEngine::DockPanel(ModernDockPanel* panel, ModernDockPanel* target, Do
+ {
+     if (!panel || !target || !m_rootNode) return false;
+     
++    wxLogDebug("DockPanel: panel=%s, target=%s, position=%d", 
++               panel->GetTitle(), target->GetTitle(), (int)position);
++    
+     // Find target node and save parent information before removing anything
+     LayoutNode* targetNode = m_rootNode->FindPanel(target);
+-    if (!targetNode) return false;
++    if (!targetNode) {
++        wxLogDebug("DockPanel: Target node not found!");
++        return false;
++    }
+     
+     // Save target parent info before any modifications
+     LayoutNode* targetParent = targetNode->GetParent();
+@@ -213,15 +220,39 @@ bool LayoutEngine::DockPanel(ModernDockPanel* panel, ModernDockPanel* target, Do
+     }
+     
+     // If panel and target are the same, do nothing
+-    if (panel == target) return false;
++    if (panel == target) {
++        wxLogDebug("DockPanel: Panel and target are the same!");
++        return false;
++    }
++    
++    // Special handling: if panel and target share the same parent and are the only children,
++    // we need to be careful not to remove the parent when removing the panel
++    LayoutNode* panelNode = m_rootNode->FindPanel(panel);
++    bool needSpecialHandling = false;
++    if (panelNode && targetNode) {
++        LayoutNode* panelParent = panelNode->GetParent();
++        LayoutNode* targetNodeParent = targetNode->GetParent();
++        if (panelParent && panelParent == targetNodeParent && 
++            panelParent->GetChildren().size() == 2) {
++            needSpecialHandling = true;
++            wxLogDebug("DockPanel: Special handling - panel and target are siblings");
++        }
++    }
+     
+     // Remove panel from current location if it's already in the tree
+-    RemovePanel(panel);
++    wxLogDebug("DockPanel: Removing panel from current location");
++    if (needSpecialHandling) {
++        // Just remove the panel node without cleanup to preserve structure
++        RemovePanelFromTree(panelNode);
++    } else {
++        RemovePanel(panel);
++    }
+     
+     // Re-find target node in case the tree structure changed
+     targetNode = m_rootNode->FindPanel(target);
+     if (!targetNode) {
+         // Target was removed during cleanup, use saved parent
++        wxLogDebug("DockPanel: Target was removed during cleanup, using saved parent");
+         InsertPanelIntoTree(panel, targetParent, position);
+     } else {
+         // Target still exists, use its current parent
+@@ -230,16 +261,18 @@ bool LayoutEngine::DockPanel(ModernDockPanel* panel, ModernDockPanel* target, Do
+             currentParent = m_rootNode.get();
+         }
+         
++        wxLogDebug("DockPanel: Inserting panel relative to target");
+         // For center docking, use the target node itself
+         if (position == DockPosition::Center) {
+             InsertPanelIntoTree(panel, targetNode, position);
+         } else {
+-            // For other positions, insert relative to target's parent
+-            InsertPanelIntoTree(panel, currentParent, position);
++            // For other positions, insert relative to target node
++            InsertPanelIntoTree(panel, targetNode, position);
+         }
+     }
+     
+     m_layoutDirty = true;
++    wxLogDebug("DockPanel: Complete");
+     return true;
+ }
+ 
+@@ -1228,23 +1261,32 @@ void LayoutEngine::CleanupEmptyNodes()
+     // Remove empty splitter nodes recursively
+     // This is a simplified implementation
+     
+-    std::function<void(LayoutNode*)> cleanup = [&](LayoutNode* node) {
+-        if (!node) return;
++    std::function<bool(LayoutNode*)> cleanup = [&](LayoutNode* node) -> bool {
++        if (!node) return false;
+         
+         // Clean children first
+         auto& children = node->GetChildren();
+         for (auto it = children.begin(); it != children.end();) {
+-            cleanup(it->get());
++            bool childEmpty = cleanup(it->get());
+             
+-            // Remove empty splitter nodes
+-            if (((*it)->GetType() == LayoutNodeType::HorizontalSplitter ||
+-                 (*it)->GetType() == LayoutNodeType::VerticalSplitter) &&
+-                (*it)->GetChildren().empty()) {
++            // Remove empty splitter nodes or nodes that became empty after cleanup
++            if (childEmpty || 
++                (((*it)->GetType() == LayoutNodeType::HorizontalSplitter ||
++                  (*it)->GetType() == LayoutNodeType::VerticalSplitter) &&
++                 (*it)->GetChildren().empty())) {
++                // If this is a splitter, unsplit it first
++                if ((*it)->GetSplitter()) {
++                    (*it)->GetSplitter()->Unsplit();
++                }
+                 it = children.erase(it);
+             } else {
+                 ++it;
+             }
+         }
++        
++        // Return true if this node is now empty (but not if it's the root)
++        return node != m_rootNode.get() && children.empty() && 
++               node->GetType() != LayoutNodeType::Panel;
+     };
+     
+     cleanup(m_rootNode.get());
+@@ -1394,12 +1436,19 @@ void LayoutEngine::InsertPanelWithSplitter(std::unique_ptr<LayoutNode> panelNode
+ {
+     if (!panelNode || !parent) return;
+     
+-    // Get the target panel from parent (assuming parent is a panel node or has panels)
++    // Determine the actual parent to insert into and the target panel
++    LayoutNode* insertParent = parent;
+     ModernDockPanel* targetPanel = nullptr;
++    
+     if (parent->GetType() == LayoutNodeType::Panel) {
++        // Parent is a panel node - we need to insert at its parent level
+         targetPanel = parent->GetPanel();
++        insertParent = parent->GetParent();
++        if (!insertParent) {
++            insertParent = m_rootNode.get();
++        }
+     } else {
+-        // Find first panel in parent's children
++        // Parent is a container - find the first panel child
+         for (auto& child : parent->GetChildren()) {
+             if (child->GetType() == LayoutNodeType::Panel) {
+                 targetPanel = child->GetPanel();
+@@ -1410,7 +1459,7 @@ void LayoutEngine::InsertPanelWithSplitter(std::unique_ptr<LayoutNode> panelNode
+     
+     if (!targetPanel) {
+         // Fallback to OrganizeByDockAreas if no target panel found
+-        OrganizeByDockAreas(std::move(panelNode), parent);
++        OrganizeByDockAreas(std::move(panelNode), insertParent);
+         return;
+     }
+     
+@@ -1432,17 +1481,13 @@ void LayoutEngine::InsertPanelWithSplitter(std::unique_ptr<LayoutNode> panelNode
+         
+         // Remove target panel from its current location
+         if (parent->GetType() == LayoutNodeType::Panel) {
+-            // Parent is the target panel, need to restructure
+-            auto grandParent = parent->GetParent();
+-            if (grandParent) {
+-                grandParent->RemoveChild(parent);
+-                parent = grandParent;
+-            }
++            // Parent is the target panel node itself
++            insertParent->RemoveChild(parent);
+         } else {
+-            // Remove target panel from parent
+-            for (auto& child : parent->GetChildren()) {
++            // Remove target panel from its parent container
++            for (auto& child : insertParent->GetChildren()) {
+                 if (child->GetType() == LayoutNodeType::Panel && child->GetPanel() == targetPanel) {
+-                    parent->RemoveChild(child.get());
++                    insertParent->RemoveChild(child.get());
+                     break;
+                 }
+             }
+@@ -1454,17 +1499,13 @@ void LayoutEngine::InsertPanelWithSplitter(std::unique_ptr<LayoutNode> panelNode
+         
+         // Remove target panel from its current location
+         if (parent->GetType() == LayoutNodeType::Panel) {
+-            // Parent is the target panel, need to restructure
+-            auto grandParent = parent->GetParent();
+-            if (grandParent) {
+-                grandParent->RemoveChild(parent);
+-                parent = grandParent;
+-            }
++            // Parent is the target panel node itself
++            insertParent->RemoveChild(parent);
+         } else {
+-            // Remove target panel from parent
+-            for (auto& child : parent->GetChildren()) {
++            // Remove target panel from its parent container
++            for (auto& child : insertParent->GetChildren()) {
+                 if (child->GetType() == LayoutNodeType::Panel && child->GetPanel() == targetPanel) {
+-                    parent->RemoveChild(child.get());
++                    insertParent->RemoveChild(child.get());
+                     break;
+                 }
+             }
+@@ -1476,7 +1517,7 @@ void LayoutEngine::InsertPanelWithSplitter(std::unique_ptr<LayoutNode> panelNode
+     splitterNode->AddChild(std::move(secondPanel));
+     
+     // Add splitter to parent
+-    parent->AddChild(std::move(splitterNode));
++    insertParent->AddChild(std::move(splitterNode));
+     
+     // Reparent panels to splitter and split
+     if (splitterWidget && splitterNode->GetChildren().size() == 2) {
diff --git a/docs/DockPanelDraggingFix.md b/docs/DockPanelDraggingFix.md
deleted file mode 100644
index 3008938..0000000
--- a/docs/DockPanelDraggingFix.md
+++ /dev/null
@@ -1,67 +0,0 @@
-# Dock Panel Dragging Fix
-
-## Problem
-When dragging dock panels to the direction indicators (dock guides), the dock layout was not changing and panels were not being properly docked.
-
-## Root Causes Identified
-
-1. **ApplyLayoutToWidgets not applying panel positions**: The `ApplyLayoutToWidgets` method in `LayoutEngine.cpp` was only handling splitter nodes but not applying the calculated layout positions to panel nodes.
-
-2. **FindTargetPanel always returning null**: The `FindTargetPanel` method in `DragDropController.cpp` had placeholder code that always returned `nullptr`, preventing proper target panel identification.
-
-3. **GetDockPosition not checking dock guides**: The `GetDockPosition` method in `ModernDockManager.cpp` was only checking mouse position relative to panels, not checking if the mouse was over dock guides.
-
-4. **No way to get target panel from dock guides**: When dragging over dock guides, there was no way to retrieve which panel the guides were associated with.
-
-## Solutions Applied
-
-### 1. Fixed ApplyLayoutToWidgets
-Added code to apply layout to panel nodes:
-```cpp
-// If this is a panel node, apply its layout
-if (node->GetType() == LayoutNodeType::Panel && node->GetPanel()) {
-    wxRect rect = node->GetRect();
-    node->GetPanel()->SetSize(rect);
-    node->GetPanel()->Show();
-}
-```
-
-### 2. Implemented FindTargetPanel
-Replaced placeholder with proper implementation that:
-- Checks if the hit-tested window is already a ModernDockPanel
-- Searches through all panels to find which one contains the hit-tested window
-- Walks up the parent hierarchy to find the containing panel
-
-### 3. Updated GetDockPosition
-Modified to check dock guides first:
-```cpp
-// First check if mouse is over a dock guide - this takes priority
-if (m_dockGuides && m_dockGuides->IsVisible()) {
-    DockPosition guidePosition = m_dockGuides->GetActivePosition();
-    if (guidePosition != DockPosition::None) {
-        return guidePosition;
-    }
-}
-```
-
-### 4. Added GetDockGuideTarget Support
-- Added `GetCurrentTarget()` method to DockGuides class
-- Added `GetDockGuideTarget()` to IDockManager interface
-- Implemented in ModernDockManager to return the current target panel from dock guides
-- Updated ValidateDrop to use the target panel from dock guides when dragging over them
-
-### 5. Added GetAllPanels Method
-- Added `GetAllPanels()` to IDockManager interface
-- Implemented in ModernDockManager to return all panels
-- Used in FindTargetPanel for searching through panels
-
-## Result
-With these fixes, dragging dock panels to the direction indicators now properly:
-1. Detects when the mouse is over a dock guide
-2. Identifies the correct target panel
-3. Calculates the appropriate dock position
-4. Updates the layout tree structure
-5. Applies the new layout to reposition panels
-6. Shows the changes visually
-
-The dock panel system now correctly responds to dragging panels onto the directional guides, allowing users to dock panels to the left, right, top, bottom, or center (as tabs) of other panels.
\ No newline at end of file
diff --git a/src/widgets/LayoutEngine.cpp b/src/widgets/LayoutEngine.cpp
index 1768b2c..ae31453 100644
--- a/src/widgets/LayoutEngine.cpp
+++ b/src/widgets/LayoutEngine.cpp
@@ -4,6 +4,7 @@
 #include "DPIManager.h"
 #include <wx/splitter.h>
 #include <wx/sizer.h>
+#include <wx/log.h>
 #include <algorithm>
 
 // LayoutNode implementation
@@ -181,7 +182,7 @@ void LayoutEngine::RemovePanel(ModernDockPanel* panel)
     // Remove from tree
     RemovePanelFromTree(panelNode);
     
-    // Clean up empty nodes
+    // Clean up empty nodes - but be careful not to remove nodes we might need
     CleanupEmptyNodes();
     
     m_layoutDirty = true;
@@ -202,9 +203,15 @@ bool LayoutEngine::DockPanel(ModernDockPanel* panel, ModernDockPanel* target, Do
 {
     if (!panel || !target || !m_rootNode) return false;
     
+    wxLogDebug("DockPanel: panel=%s, target=%s, position=%d", 
+               panel->GetTitle(), target->GetTitle(), (int)position);
+    
     // Find target node and save parent information before removing anything
     LayoutNode* targetNode = m_rootNode->FindPanel(target);
-    if (!targetNode) return false;
+    if (!targetNode) {
+        wxLogDebug("DockPanel: Target node not found!");
+        return false;
+    }
     
     // Save target parent info before any modifications
     LayoutNode* targetParent = targetNode->GetParent();
@@ -213,15 +220,39 @@ bool LayoutEngine::DockPanel(ModernDockPanel* panel, ModernDockPanel* target, Do
     }
     
     // If panel and target are the same, do nothing
-    if (panel == target) return false;
+    if (panel == target) {
+        wxLogDebug("DockPanel: Panel and target are the same!");
+        return false;
+    }
+    
+    // Special handling: if panel and target share the same parent and are the only children,
+    // we need to be careful not to remove the parent when removing the panel
+    LayoutNode* panelNode = m_rootNode->FindPanel(panel);
+    bool needSpecialHandling = false;
+    if (panelNode && targetNode) {
+        LayoutNode* panelParent = panelNode->GetParent();
+        LayoutNode* targetNodeParent = targetNode->GetParent();
+        if (panelParent && panelParent == targetNodeParent && 
+            panelParent->GetChildren().size() == 2) {
+            needSpecialHandling = true;
+            wxLogDebug("DockPanel: Special handling - panel and target are siblings");
+        }
+    }
     
     // Remove panel from current location if it's already in the tree
-    RemovePanel(panel);
+    wxLogDebug("DockPanel: Removing panel from current location");
+    if (needSpecialHandling) {
+        // Just remove the panel node without cleanup to preserve structure
+        RemovePanelFromTree(panelNode);
+    } else {
+        RemovePanel(panel);
+    }
     
     // Re-find target node in case the tree structure changed
     targetNode = m_rootNode->FindPanel(target);
     if (!targetNode) {
         // Target was removed during cleanup, use saved parent
+        wxLogDebug("DockPanel: Target was removed during cleanup, using saved parent");
         InsertPanelIntoTree(panel, targetParent, position);
     } else {
         // Target still exists, use its current parent
@@ -230,16 +261,18 @@ bool LayoutEngine::DockPanel(ModernDockPanel* panel, ModernDockPanel* target, Do
             currentParent = m_rootNode.get();
         }
         
+        wxLogDebug("DockPanel: Inserting panel relative to target");
         // For center docking, use the target node itself
         if (position == DockPosition::Center) {
             InsertPanelIntoTree(panel, targetNode, position);
         } else {
-            // For other positions, insert relative to target's parent
-            InsertPanelIntoTree(panel, currentParent, position);
+            // For other positions, insert relative to target node
+            InsertPanelIntoTree(panel, targetNode, position);
         }
     }
     
     m_layoutDirty = true;
+    wxLogDebug("DockPanel: Complete");
     return true;
 }
 
@@ -1228,23 +1261,32 @@ void LayoutEngine::CleanupEmptyNodes()
     // Remove empty splitter nodes recursively
     // This is a simplified implementation
     
-    std::function<void(LayoutNode*)> cleanup = [&](LayoutNode* node) {
-        if (!node) return;
+    std::function<bool(LayoutNode*)> cleanup = [&](LayoutNode* node) -> bool {
+        if (!node) return false;
         
         // Clean children first
         auto& children = node->GetChildren();
         for (auto it = children.begin(); it != children.end();) {
-            cleanup(it->get());
+            bool childEmpty = cleanup(it->get());
             
-            // Remove empty splitter nodes
-            if (((*it)->GetType() == LayoutNodeType::HorizontalSplitter ||
-                 (*it)->GetType() == LayoutNodeType::VerticalSplitter) &&
-                (*it)->GetChildren().empty()) {
+            // Remove empty splitter nodes or nodes that became empty after cleanup
+            if (childEmpty || 
+                (((*it)->GetType() == LayoutNodeType::HorizontalSplitter ||
+                  (*it)->GetType() == LayoutNodeType::VerticalSplitter) &&
+                 (*it)->GetChildren().empty())) {
+                // If this is a splitter, unsplit it first
+                if ((*it)->GetSplitter()) {
+                    (*it)->GetSplitter()->Unsplit();
+                }
                 it = children.erase(it);
             } else {
                 ++it;
             }
         }
+        
+        // Return true if this node is now empty (but not if it's the root)
+        return node != m_rootNode.get() && children.empty() && 
+               node->GetType() != LayoutNodeType::Panel;
     };
     
     cleanup(m_rootNode.get());
@@ -1394,12 +1436,19 @@ void LayoutEngine::InsertPanelWithSplitter(std::unique_ptr<LayoutNode> panelNode
 {
     if (!panelNode || !parent) return;
     
-    // Get the target panel from parent (assuming parent is a panel node or has panels)
+    // Determine the actual parent to insert into and the target panel
+    LayoutNode* insertParent = parent;
     ModernDockPanel* targetPanel = nullptr;
+    
     if (parent->GetType() == LayoutNodeType::Panel) {
+        // Parent is a panel node - we need to insert at its parent level
         targetPanel = parent->GetPanel();
+        insertParent = parent->GetParent();
+        if (!insertParent) {
+            insertParent = m_rootNode.get();
+        }
     } else {
-        // Find first panel in parent's children
+        // Parent is a container - find the first panel child
         for (auto& child : parent->GetChildren()) {
             if (child->GetType() == LayoutNodeType::Panel) {
                 targetPanel = child->GetPanel();
@@ -1410,7 +1459,7 @@ void LayoutEngine::InsertPanelWithSplitter(std::unique_ptr<LayoutNode> panelNode
     
     if (!targetPanel) {
         // Fallback to OrganizeByDockAreas if no target panel found
-        OrganizeByDockAreas(std::move(panelNode), parent);
+        OrganizeByDockAreas(std::move(panelNode), insertParent);
         return;
     }
     
@@ -1432,17 +1481,13 @@ void LayoutEngine::InsertPanelWithSplitter(std::unique_ptr<LayoutNode> panelNode
         
         // Remove target panel from its current location
         if (parent->GetType() == LayoutNodeType::Panel) {
-            // Parent is the target panel, need to restructure
-            auto grandParent = parent->GetParent();
-            if (grandParent) {
-                grandParent->RemoveChild(parent);
-                parent = grandParent;
-            }
+            // Parent is the target panel node itself
+            insertParent->RemoveChild(parent);
         } else {
-            // Remove target panel from parent
-            for (auto& child : parent->GetChildren()) {
+            // Remove target panel from its parent container
+            for (auto& child : insertParent->GetChildren()) {
                 if (child->GetType() == LayoutNodeType::Panel && child->GetPanel() == targetPanel) {
-                    parent->RemoveChild(child.get());
+                    insertParent->RemoveChild(child.get());
                     break;
                 }
             }
@@ -1454,17 +1499,13 @@ void LayoutEngine::InsertPanelWithSplitter(std::unique_ptr<LayoutNode> panelNode
         
         // Remove target panel from its current location
         if (parent->GetType() == LayoutNodeType::Panel) {
-            // Parent is the target panel, need to restructure
-            auto grandParent = parent->GetParent();
-            if (grandParent) {
-                grandParent->RemoveChild(parent);
-                parent = grandParent;
-            }
+            // Parent is the target panel node itself
+            insertParent->RemoveChild(parent);
         } else {
-            // Remove target panel from parent
-            for (auto& child : parent->GetChildren()) {
+            // Remove target panel from its parent container
+            for (auto& child : insertParent->GetChildren()) {
                 if (child->GetType() == LayoutNodeType::Panel && child->GetPanel() == targetPanel) {
-                    parent->RemoveChild(child.get());
+                    insertParent->RemoveChild(child.get());
                     break;
                 }
             }
@@ -1476,7 +1517,7 @@ void LayoutEngine::InsertPanelWithSplitter(std::unique_ptr<LayoutNode> panelNode
     splitterNode->AddChild(std::move(secondPanel));
     
     // Add splitter to parent
-    parent->AddChild(std::move(splitterNode));
+    insertParent->AddChild(std::move(splitterNode));
     
     // Reparent panels to splitter and split
     if (splitterWidget && splitterNode->GetChildren().size() == 2) {
