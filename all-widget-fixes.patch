diff --git a/include/widgets/DockGuides.h b/include/widgets/DockGuides.h
index 274d36d..e2443ee 100644
--- a/include/widgets/DockGuides.h
+++ b/include/widgets/DockGuides.h
@@ -130,6 +130,7 @@ public:
     
     DockPosition GetActivePosition() const;
     bool IsVisible() const { return m_visible; }
+    ModernDockPanel* GetCurrentTarget() const { return m_currentTarget; }
     void SetEnabledDirections(bool center, bool left, bool right, bool top, bool bottom) {
         m_centerEnabled = center; m_leftEnabled = left; m_rightEnabled = right; m_topEnabled = top; m_bottomEnabled = bottom;
         if (m_edgeGuides) {
diff --git a/include/widgets/IDockManager.h b/include/widgets/IDockManager.h
index 5d337a4..afbc11e 100644
--- a/include/widgets/IDockManager.h
+++ b/include/widgets/IDockManager.h
@@ -6,6 +6,7 @@
 #include <wx/string.h>
 #include <wx/event.h>
 #include <functional>
+#include <vector>
 
 // Forward declarations
 class LayoutNode;
@@ -54,6 +55,7 @@ public:
     virtual void ShowDockGuides(wxWindow* target) = 0;  // Overloaded version
     virtual void SetDockGuideConfig(const DockGuideConfig& config) = 0;
     virtual DockGuideConfig GetDockGuideConfig() const = 0;
+    virtual ModernDockPanel* GetDockGuideTarget() const = 0;
     
     // Preview and hit testing
     virtual void ShowPreviewRect(const wxRect& rect, DockPosition position) = 0;
@@ -102,6 +104,9 @@ public:
     virtual int GetSplitterCount() const = 0;
     virtual wxString GetLayoutStatistics() const = 0;
     virtual void DumpLayoutTree() const = 0;
+    
+    // Panel access
+    virtual std::vector<ModernDockPanel*> GetAllPanels() const = 0;
 };
 
 
diff --git a/include/widgets/ModernDockManager.h b/include/widgets/ModernDockManager.h
index a161d63..be43def 100644
--- a/include/widgets/ModernDockManager.h
+++ b/include/widgets/ModernDockManager.h
@@ -90,6 +90,7 @@ public:
     void ShowDockGuides(wxWindow* target) override;
     void SetDockGuideConfig(const DockGuideConfig& config) override;
     DockGuideConfig GetDockGuideConfig() const override;
+    ModernDockPanel* GetDockGuideTarget() const override;
     
     // Preview and hit testing
     void ShowPreviewRect(const wxRect& rect, DockPosition position) override;
@@ -137,6 +138,7 @@ public:
     int GetSplitterCount() const override;
     wxString GetLayoutStatistics() const override;
     void DumpLayoutTree() const override;
+    std::vector<ModernDockPanel*> GetAllPanels() const override;
     
     // Configuration
     void EnableLayoutCaching(bool enabled);
diff --git a/src/widgets/DragDropController.cpp b/src/widgets/DragDropController.cpp
index 044f6ea..b1a1405 100644
--- a/src/widgets/DragDropController.cpp
+++ b/src/widgets/DragDropController.cpp
@@ -136,16 +136,34 @@ DropValidation DragDropController::ValidateDrop(const wxPoint& pos) const
         return validation;
     }
     
-    // Find target panel under cursor
-    validation.targetPanel = FindTargetPanel(pos);
-    if (!validation.targetPanel) {
-        return validation;
-    }
-    
-    // Calculate dock position
-    validation.position = CalculateDockPosition(validation.targetPanel, pos);
-    if (validation.position == DockPosition::None) {
-        return validation;
+    // Calculate dock position first to check if we're over dock guides
+    DockPosition guidePosition = m_manager->GetDockPosition(nullptr, pos);
+    
+    // If we're over a dock guide, get the target from the dock guides
+    if (guidePosition != DockPosition::None) {
+        // Get target panel from dock guides
+        validation.targetPanel = m_manager->GetDockGuideTarget();
+        if (!validation.targetPanel) {
+            // If no target from guides, try to find panel under cursor
+            validation.targetPanel = FindTargetPanel(pos);
+            if (!validation.targetPanel) {
+                // If still no panel found, we can't complete the drop
+                return validation;
+            }
+        }
+        validation.position = guidePosition;
+    } else {
+        // Find target panel under cursor
+        validation.targetPanel = FindTargetPanel(pos);
+        if (!validation.targetPanel) {
+            return validation;
+        }
+        
+        // Calculate dock position based on panel
+        validation.position = CalculateDockPosition(validation.targetPanel, pos);
+        if (validation.position == DockPosition::None) {
+            return validation;
+        }
     }
     
     // Check if drop is allowed
@@ -252,10 +270,31 @@ ModernDockPanel* DragDropController::FindTargetPanel(const wxPoint& screenPos) c
     
     // Convert wxWindow* to ModernDockPanel* if possible
     if (result) {
-        // Try to find the panel that contains this window
-        // This is a simplified approach - in a real implementation,
-        // you might want to maintain a mapping or use a different approach
-        return nullptr; // Placeholder - need proper conversion logic
+        // Check if the result is already a ModernDockPanel
+        ModernDockPanel* panel = dynamic_cast<ModernDockPanel*>(result);
+        if (panel) {
+            return panel;
+        }
+        
+        // If not, find the panel that contains this window
+        // Get all panels from the manager
+        std::vector<ModernDockPanel*> panels = m_manager->GetAllPanels();
+        for (ModernDockPanel* panel : panels) {
+            if (panel && panel->IsShown()) {
+                // Check if this panel contains the hit-tested window
+                if (panel == result || panel->GetContent() == result) {
+                    return panel;
+                }
+                // Also check if the window is a child of the panel
+                wxWindow* parent = result->GetParent();
+                while (parent) {
+                    if (parent == panel || parent == panel->GetContent()) {
+                        return panel;
+                    }
+                    parent = parent->GetParent();
+                }
+            }
+        }
     }
     
     return nullptr;
diff --git a/src/widgets/LayoutEngine.cpp b/src/widgets/LayoutEngine.cpp
index 36c6d1b..ae31453 100644
--- a/src/widgets/LayoutEngine.cpp
+++ b/src/widgets/LayoutEngine.cpp
@@ -4,6 +4,7 @@
 #include "DPIManager.h"
 #include <wx/splitter.h>
 #include <wx/sizer.h>
+#include <wx/log.h>
 #include <algorithm>
 
 // LayoutNode implementation
@@ -181,7 +182,7 @@ void LayoutEngine::RemovePanel(ModernDockPanel* panel)
     // Remove from tree
     RemovePanelFromTree(panelNode);
     
-    // Clean up empty nodes
+    // Clean up empty nodes - but be careful not to remove nodes we might need
     CleanupEmptyNodes();
     
     m_layoutDirty = true;
@@ -202,9 +203,15 @@ bool LayoutEngine::DockPanel(ModernDockPanel* panel, ModernDockPanel* target, Do
 {
     if (!panel || !target || !m_rootNode) return false;
     
+    wxLogDebug("DockPanel: panel=%s, target=%s, position=%d", 
+               panel->GetTitle(), target->GetTitle(), (int)position);
+    
     // Find target node and save parent information before removing anything
     LayoutNode* targetNode = m_rootNode->FindPanel(target);
-    if (!targetNode) return false;
+    if (!targetNode) {
+        wxLogDebug("DockPanel: Target node not found!");
+        return false;
+    }
     
     // Save target parent info before any modifications
     LayoutNode* targetParent = targetNode->GetParent();
@@ -213,15 +220,39 @@ bool LayoutEngine::DockPanel(ModernDockPanel* panel, ModernDockPanel* target, Do
     }
     
     // If panel and target are the same, do nothing
-    if (panel == target) return false;
+    if (panel == target) {
+        wxLogDebug("DockPanel: Panel and target are the same!");
+        return false;
+    }
+    
+    // Special handling: if panel and target share the same parent and are the only children,
+    // we need to be careful not to remove the parent when removing the panel
+    LayoutNode* panelNode = m_rootNode->FindPanel(panel);
+    bool needSpecialHandling = false;
+    if (panelNode && targetNode) {
+        LayoutNode* panelParent = panelNode->GetParent();
+        LayoutNode* targetNodeParent = targetNode->GetParent();
+        if (panelParent && panelParent == targetNodeParent && 
+            panelParent->GetChildren().size() == 2) {
+            needSpecialHandling = true;
+            wxLogDebug("DockPanel: Special handling - panel and target are siblings");
+        }
+    }
     
     // Remove panel from current location if it's already in the tree
-    RemovePanel(panel);
+    wxLogDebug("DockPanel: Removing panel from current location");
+    if (needSpecialHandling) {
+        // Just remove the panel node without cleanup to preserve structure
+        RemovePanelFromTree(panelNode);
+    } else {
+        RemovePanel(panel);
+    }
     
     // Re-find target node in case the tree structure changed
     targetNode = m_rootNode->FindPanel(target);
     if (!targetNode) {
         // Target was removed during cleanup, use saved parent
+        wxLogDebug("DockPanel: Target was removed during cleanup, using saved parent");
         InsertPanelIntoTree(panel, targetParent, position);
     } else {
         // Target still exists, use its current parent
@@ -230,16 +261,18 @@ bool LayoutEngine::DockPanel(ModernDockPanel* panel, ModernDockPanel* target, Do
             currentParent = m_rootNode.get();
         }
         
+        wxLogDebug("DockPanel: Inserting panel relative to target");
         // For center docking, use the target node itself
         if (position == DockPosition::Center) {
             InsertPanelIntoTree(panel, targetNode, position);
         } else {
-            // For other positions, insert relative to target's parent
-            InsertPanelIntoTree(panel, currentParent, position);
+            // For other positions, insert relative to target node
+            InsertPanelIntoTree(panel, targetNode, position);
         }
     }
     
     m_layoutDirty = true;
+    wxLogDebug("DockPanel: Complete");
     return true;
 }
 
@@ -847,6 +880,13 @@ void LayoutEngine::ApplyLayoutToWidgets(LayoutNode* node)
 {
     if (!node) return;
     
+    // If this is a panel node, apply its layout
+    if (node->GetType() == LayoutNodeType::Panel && node->GetPanel()) {
+        wxRect rect = node->GetRect();
+        node->GetPanel()->SetSize(rect);
+        node->GetPanel()->Show();
+    }
+    
     // If this is a splitter node, ensure splitter control is properly displayed
     if (node->GetType() == LayoutNodeType::HorizontalSplitter || 
         node->GetType() == LayoutNodeType::VerticalSplitter) {
@@ -1221,23 +1261,32 @@ void LayoutEngine::CleanupEmptyNodes()
     // Remove empty splitter nodes recursively
     // This is a simplified implementation
     
-    std::function<void(LayoutNode*)> cleanup = [&](LayoutNode* node) {
-        if (!node) return;
+    std::function<bool(LayoutNode*)> cleanup = [&](LayoutNode* node) -> bool {
+        if (!node) return false;
         
         // Clean children first
         auto& children = node->GetChildren();
         for (auto it = children.begin(); it != children.end();) {
-            cleanup(it->get());
+            bool childEmpty = cleanup(it->get());
             
-            // Remove empty splitter nodes
-            if (((*it)->GetType() == LayoutNodeType::HorizontalSplitter ||
-                 (*it)->GetType() == LayoutNodeType::VerticalSplitter) &&
-                (*it)->GetChildren().empty()) {
+            // Remove empty splitter nodes or nodes that became empty after cleanup
+            if (childEmpty || 
+                (((*it)->GetType() == LayoutNodeType::HorizontalSplitter ||
+                  (*it)->GetType() == LayoutNodeType::VerticalSplitter) &&
+                 (*it)->GetChildren().empty())) {
+                // If this is a splitter, unsplit it first
+                if ((*it)->GetSplitter()) {
+                    (*it)->GetSplitter()->Unsplit();
+                }
                 it = children.erase(it);
             } else {
                 ++it;
             }
         }
+        
+        // Return true if this node is now empty (but not if it's the root)
+        return node != m_rootNode.get() && children.empty() && 
+               node->GetType() != LayoutNodeType::Panel;
     };
     
     cleanup(m_rootNode.get());
@@ -1387,12 +1436,19 @@ void LayoutEngine::InsertPanelWithSplitter(std::unique_ptr<LayoutNode> panelNode
 {
     if (!panelNode || !parent) return;
     
-    // Get the target panel from parent (assuming parent is a panel node or has panels)
+    // Determine the actual parent to insert into and the target panel
+    LayoutNode* insertParent = parent;
     ModernDockPanel* targetPanel = nullptr;
+    
     if (parent->GetType() == LayoutNodeType::Panel) {
+        // Parent is a panel node - we need to insert at its parent level
         targetPanel = parent->GetPanel();
+        insertParent = parent->GetParent();
+        if (!insertParent) {
+            insertParent = m_rootNode.get();
+        }
     } else {
-        // Find first panel in parent's children
+        // Parent is a container - find the first panel child
         for (auto& child : parent->GetChildren()) {
             if (child->GetType() == LayoutNodeType::Panel) {
                 targetPanel = child->GetPanel();
@@ -1403,7 +1459,7 @@ void LayoutEngine::InsertPanelWithSplitter(std::unique_ptr<LayoutNode> panelNode
     
     if (!targetPanel) {
         // Fallback to OrganizeByDockAreas if no target panel found
-        OrganizeByDockAreas(std::move(panelNode), parent);
+        OrganizeByDockAreas(std::move(panelNode), insertParent);
         return;
     }
     
@@ -1425,17 +1481,13 @@ void LayoutEngine::InsertPanelWithSplitter(std::unique_ptr<LayoutNode> panelNode
         
         // Remove target panel from its current location
         if (parent->GetType() == LayoutNodeType::Panel) {
-            // Parent is the target panel, need to restructure
-            auto grandParent = parent->GetParent();
-            if (grandParent) {
-                grandParent->RemoveChild(parent);
-                parent = grandParent;
-            }
+            // Parent is the target panel node itself
+            insertParent->RemoveChild(parent);
         } else {
-            // Remove target panel from parent
-            for (auto& child : parent->GetChildren()) {
+            // Remove target panel from its parent container
+            for (auto& child : insertParent->GetChildren()) {
                 if (child->GetType() == LayoutNodeType::Panel && child->GetPanel() == targetPanel) {
-                    parent->RemoveChild(child.get());
+                    insertParent->RemoveChild(child.get());
                     break;
                 }
             }
@@ -1447,17 +1499,13 @@ void LayoutEngine::InsertPanelWithSplitter(std::unique_ptr<LayoutNode> panelNode
         
         // Remove target panel from its current location
         if (parent->GetType() == LayoutNodeType::Panel) {
-            // Parent is the target panel, need to restructure
-            auto grandParent = parent->GetParent();
-            if (grandParent) {
-                grandParent->RemoveChild(parent);
-                parent = grandParent;
-            }
+            // Parent is the target panel node itself
+            insertParent->RemoveChild(parent);
         } else {
-            // Remove target panel from parent
-            for (auto& child : parent->GetChildren()) {
+            // Remove target panel from its parent container
+            for (auto& child : insertParent->GetChildren()) {
                 if (child->GetType() == LayoutNodeType::Panel && child->GetPanel() == targetPanel) {
-                    parent->RemoveChild(child.get());
+                    insertParent->RemoveChild(child.get());
                     break;
                 }
             }
@@ -1469,7 +1517,7 @@ void LayoutEngine::InsertPanelWithSplitter(std::unique_ptr<LayoutNode> panelNode
     splitterNode->AddChild(std::move(secondPanel));
     
     // Add splitter to parent
-    parent->AddChild(std::move(splitterNode));
+    insertParent->AddChild(std::move(splitterNode));
     
     // Reparent panels to splitter and split
     if (splitterWidget && splitterNode->GetChildren().size() == 2) {
diff --git a/src/widgets/ModernDockManager.cpp b/src/widgets/ModernDockManager.cpp
index 20b663e..1b97f27 100644
--- a/src/widgets/ModernDockManager.cpp
+++ b/src/widgets/ModernDockManager.cpp
@@ -330,7 +330,15 @@ DockPosition ModernDockManager::GetDockPosition(wxWindow* target, const wxPoint&
 {
     if (!target) return DockPosition::None;
     
-    // Calculate dock position based on mouse position relative to target panel
+    // First check if mouse is over a dock guide - this takes priority
+    if (m_dockGuides && m_dockGuides->IsVisible()) {
+        DockPosition guidePosition = m_dockGuides->GetActivePosition();
+        if (guidePosition != DockPosition::None) {
+            return guidePosition;
+        }
+    }
+    
+    // If not over a guide, calculate dock position based on mouse position relative to target panel
     wxRect targetRect;
     wxPoint targetScreenPos = target->GetScreenPosition();
     wxSize targetSize = target->GetSize();
@@ -922,6 +930,14 @@ DockGuideConfig ModernDockManager::GetDockGuideConfig() const
     return DockGuideConfig(); // Placeholder
 }
 
+ModernDockPanel* ModernDockManager::GetDockGuideTarget() const
+{
+    if (m_dockGuides) {
+        return m_dockGuides->GetCurrentTarget();
+    }
+    return nullptr;
+}
+
 // Event handling
 void ModernDockManager::BindDockEvent(wxEventType eventType, 
                                       std::function<void(const DockEventData&)> handler)
@@ -1055,6 +1071,15 @@ int ModernDockManager::GetPanelCount() const
     return count;
 }
 
+std::vector<ModernDockPanel*> ModernDockManager::GetAllPanels() const
+{
+    std::vector<ModernDockPanel*> allPanels;
+    for (const auto& [area, panels] : m_panels) {
+        allPanels.insert(allPanels.end(), panels.begin(), panels.end());
+    }
+    return allPanels;
+}
+
 int ModernDockManager::GetContainerCount() const
 {
     return 0; // Placeholder
